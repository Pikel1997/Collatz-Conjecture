import numpy as np
import matplotlib.pyplot as plt
import random


# main function, just applying 3n+1 to odd numbers and dividing the even numbers by 2. 
def collatz(n):
    global sequence, stoppingTime, count
    sequence = []
    stoppingTime = []
    count = 0
    while n != 1:
        count += 1
        stoppingTime.append(count)
        if n % 2 > 0:
             n =((3 * n) + 1)
             sequence.append(n)
        else:
            n = (n // 2)
            sequence.append(n)

# def ploty():
#   global zerolist
#   zeroarray = np.zeros(count)
#   zerolist = zeroarray.tolist()
#   for x in sequence:
#     po = po + 0.1
#     y = sequence.index(x)
    
#     if x == 2 or x == 4:
#         zerolist[y] = 0
#     elif (x % 2) == 0:
#         zerolist[y] = po + 0.1
#     else:
#         zerolist[y] = po - 0.1

# running the test for the first thousand numbers and plotting each sequence.
def result():
    for i in range(1, 100):
        r = lambda: random.randint(0, 255)
        collatz(i)
        print(sequence, (f"\n Stopping Time - {count}"))
        plt.plot(np.array(sequence),
                 np.array(stoppingTime),
                 color='#%02X%02X%02X' % (r(), r(), r()),
                 marker='o',
                 markerfacecolor='black',
                 markersize=3)
        try:
            # np.max() returns a value error because of the empty array generated by the first sequence
            mvalues = np.max(np.array(sequence))
            # plt.annotate(mvalues,
            #              (np.array(sequence).argmax(), mvalues),
            #              textcoords="offset points",
            #              xytext=(0, 5),
            #              ha='center')
        except ValueError:
            pass


plt.title("Collatz")
plt.xlabel("Iterations/Steps")
plt.ylabel("Numbers")
plt.gca().spines['top'].set_visible(False)
plt.gca().spines['right'].set_visible(False)
result()
plt.grid()
plt.show()

